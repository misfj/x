// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"coredx/db/dal/model"
)

func newDataDirect2(db *gorm.DB, opts ...gen.DOOption) dataDirect2 {
	_dataDirect2 := dataDirect2{}

	_dataDirect2.dataDirect2Do.UseDB(db, opts...)
	_dataDirect2.dataDirect2Do.UseModel(&model.DataDirect2{})

	tableName := _dataDirect2.dataDirect2Do.TableName()
	_dataDirect2.ALL = field.NewAsterisk(tableName)
	_dataDirect2.ID = field.NewInt64(tableName, "id")
	_dataDirect2.CreateAt = field.NewTime(tableName, "create_at")
	_dataDirect2.UpdateAt = field.NewTime(tableName, "update_at")
	_dataDirect2.DeleteAt = field.NewTime(tableName, "delete_at")
	_dataDirect2.DirectId2 = field.NewString(tableName, "direct_id2")
	_dataDirect2.DirectId2Name = field.NewString(tableName, "direct_id2_name")

	_dataDirect2.fillFieldMap()

	return _dataDirect2
}

type dataDirect2 struct {
	dataDirect2Do dataDirect2Do

	ALL           field.Asterisk
	ID            field.Int64  // 数据id
	CreateAt      field.Time   // 创建时间
	UpdateAt      field.Time   // 更新时间
	DeleteAt      field.Time   // 删除时间
	DirectId2     field.String // 目录id(00000000进行表示)
	DirectId2Name field.String // 目录名称

	fieldMap map[string]field.Expr
}

func (d dataDirect2) Table(newTableName string) *dataDirect2 {
	d.dataDirect2Do.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dataDirect2) As(alias string) *dataDirect2 {
	d.dataDirect2Do.DO = *(d.dataDirect2Do.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dataDirect2) updateTableName(table string) *dataDirect2 {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.CreateAt = field.NewTime(table, "create_at")
	d.UpdateAt = field.NewTime(table, "update_at")
	d.DeleteAt = field.NewTime(table, "delete_at")
	d.DirectId2 = field.NewString(table, "direct_id2")
	d.DirectId2Name = field.NewString(table, "direct_id2_name")

	d.fillFieldMap()

	return d
}

func (d *dataDirect2) WithContext(ctx context.Context) IDataDirect2Do {
	return d.dataDirect2Do.WithContext(ctx)
}

func (d dataDirect2) TableName() string { return d.dataDirect2Do.TableName() }

func (d dataDirect2) Alias() string { return d.dataDirect2Do.Alias() }

func (d dataDirect2) Columns(cols ...field.Expr) gen.Columns { return d.dataDirect2Do.Columns(cols...) }

func (d *dataDirect2) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dataDirect2) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 6)
	d.fieldMap["id"] = d.ID
	d.fieldMap["create_at"] = d.CreateAt
	d.fieldMap["update_at"] = d.UpdateAt
	d.fieldMap["delete_at"] = d.DeleteAt
	d.fieldMap["direct_id2"] = d.DirectId2
	d.fieldMap["direct_id2_name"] = d.DirectId2Name
}

func (d dataDirect2) clone(db *gorm.DB) dataDirect2 {
	d.dataDirect2Do.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dataDirect2) replaceDB(db *gorm.DB) dataDirect2 {
	d.dataDirect2Do.ReplaceDB(db)
	return d
}

type dataDirect2Do struct{ gen.DO }

type IDataDirect2Do interface {
	gen.SubQuery
	Debug() IDataDirect2Do
	WithContext(ctx context.Context) IDataDirect2Do
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDataDirect2Do
	WriteDB() IDataDirect2Do
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDataDirect2Do
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDataDirect2Do
	Not(conds ...gen.Condition) IDataDirect2Do
	Or(conds ...gen.Condition) IDataDirect2Do
	Select(conds ...field.Expr) IDataDirect2Do
	Where(conds ...gen.Condition) IDataDirect2Do
	Order(conds ...field.Expr) IDataDirect2Do
	Distinct(cols ...field.Expr) IDataDirect2Do
	Omit(cols ...field.Expr) IDataDirect2Do
	Join(table schema.Tabler, on ...field.Expr) IDataDirect2Do
	LeftJoin(table schema.Tabler, on ...field.Expr) IDataDirect2Do
	RightJoin(table schema.Tabler, on ...field.Expr) IDataDirect2Do
	Group(cols ...field.Expr) IDataDirect2Do
	Having(conds ...gen.Condition) IDataDirect2Do
	Limit(limit int) IDataDirect2Do
	Offset(offset int) IDataDirect2Do
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDataDirect2Do
	Unscoped() IDataDirect2Do
	Create(values ...*model.DataDirect2) error
	CreateInBatches(values []*model.DataDirect2, batchSize int) error
	Save(values ...*model.DataDirect2) error
	First() (*model.DataDirect2, error)
	Take() (*model.DataDirect2, error)
	Last() (*model.DataDirect2, error)
	Find() ([]*model.DataDirect2, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DataDirect2, err error)
	FindInBatches(result *[]*model.DataDirect2, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DataDirect2) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDataDirect2Do
	Assign(attrs ...field.AssignExpr) IDataDirect2Do
	Joins(fields ...field.RelationField) IDataDirect2Do
	Preload(fields ...field.RelationField) IDataDirect2Do
	FirstOrInit() (*model.DataDirect2, error)
	FirstOrCreate() (*model.DataDirect2, error)
	FindByPage(offset int, limit int) (result []*model.DataDirect2, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDataDirect2Do
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dataDirect2Do) Debug() IDataDirect2Do {
	return d.withDO(d.DO.Debug())
}

func (d dataDirect2Do) WithContext(ctx context.Context) IDataDirect2Do {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dataDirect2Do) ReadDB() IDataDirect2Do {
	return d.Clauses(dbresolver.Read)
}

func (d dataDirect2Do) WriteDB() IDataDirect2Do {
	return d.Clauses(dbresolver.Write)
}

func (d dataDirect2Do) Session(config *gorm.Session) IDataDirect2Do {
	return d.withDO(d.DO.Session(config))
}

func (d dataDirect2Do) Clauses(conds ...clause.Expression) IDataDirect2Do {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dataDirect2Do) Returning(value interface{}, columns ...string) IDataDirect2Do {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dataDirect2Do) Not(conds ...gen.Condition) IDataDirect2Do {
	return d.withDO(d.DO.Not(conds...))
}

func (d dataDirect2Do) Or(conds ...gen.Condition) IDataDirect2Do {
	return d.withDO(d.DO.Or(conds...))
}

func (d dataDirect2Do) Select(conds ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Select(conds...))
}

func (d dataDirect2Do) Where(conds ...gen.Condition) IDataDirect2Do {
	return d.withDO(d.DO.Where(conds...))
}

func (d dataDirect2Do) Order(conds ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Order(conds...))
}

func (d dataDirect2Do) Distinct(cols ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dataDirect2Do) Omit(cols ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dataDirect2Do) Join(table schema.Tabler, on ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dataDirect2Do) LeftJoin(table schema.Tabler, on ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dataDirect2Do) RightJoin(table schema.Tabler, on ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dataDirect2Do) Group(cols ...field.Expr) IDataDirect2Do {
	return d.withDO(d.DO.Group(cols...))
}

func (d dataDirect2Do) Having(conds ...gen.Condition) IDataDirect2Do {
	return d.withDO(d.DO.Having(conds...))
}

func (d dataDirect2Do) Limit(limit int) IDataDirect2Do {
	return d.withDO(d.DO.Limit(limit))
}

func (d dataDirect2Do) Offset(offset int) IDataDirect2Do {
	return d.withDO(d.DO.Offset(offset))
}

func (d dataDirect2Do) Scopes(funcs ...func(gen.Dao) gen.Dao) IDataDirect2Do {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dataDirect2Do) Unscoped() IDataDirect2Do {
	return d.withDO(d.DO.Unscoped())
}

func (d dataDirect2Do) Create(values ...*model.DataDirect2) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dataDirect2Do) CreateInBatches(values []*model.DataDirect2, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dataDirect2Do) Save(values ...*model.DataDirect2) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dataDirect2Do) First() (*model.DataDirect2, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataDirect2), nil
	}
}

func (d dataDirect2Do) Take() (*model.DataDirect2, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataDirect2), nil
	}
}

func (d dataDirect2Do) Last() (*model.DataDirect2, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataDirect2), nil
	}
}

func (d dataDirect2Do) Find() ([]*model.DataDirect2, error) {
	result, err := d.DO.Find()
	return result.([]*model.DataDirect2), err
}

func (d dataDirect2Do) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DataDirect2, err error) {
	buf := make([]*model.DataDirect2, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dataDirect2Do) FindInBatches(result *[]*model.DataDirect2, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dataDirect2Do) Attrs(attrs ...field.AssignExpr) IDataDirect2Do {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dataDirect2Do) Assign(attrs ...field.AssignExpr) IDataDirect2Do {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dataDirect2Do) Joins(fields ...field.RelationField) IDataDirect2Do {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dataDirect2Do) Preload(fields ...field.RelationField) IDataDirect2Do {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dataDirect2Do) FirstOrInit() (*model.DataDirect2, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataDirect2), nil
	}
}

func (d dataDirect2Do) FirstOrCreate() (*model.DataDirect2, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataDirect2), nil
	}
}

func (d dataDirect2Do) FindByPage(offset int, limit int) (result []*model.DataDirect2, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dataDirect2Do) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dataDirect2Do) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dataDirect2Do) Delete(models ...*model.DataDirect2) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dataDirect2Do) withDO(do gen.Dao) *dataDirect2Do {
	d.DO = *do.(*gen.DO)
	return d
}

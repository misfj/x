// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"coredx/db/dal/model"
)

func newSysMsg(db *gorm.DB, opts ...gen.DOOption) sysMsg {
	_sysMsg := sysMsg{}

	_sysMsg.sysMsgDo.UseDB(db, opts...)
	_sysMsg.sysMsgDo.UseModel(&model.SysMsg{})

	tableName := _sysMsg.sysMsgDo.TableName()
	_sysMsg.ALL = field.NewAsterisk(tableName)
	_sysMsg.ID = field.NewInt64(tableName, "id")
	_sysMsg.CreateTime = field.NewTime(tableName, "create_time")
	_sysMsg.UpdateTime = field.NewTime(tableName, "update_time")
	_sysMsg.DeleteTime = field.NewTime(tableName, "delete_time")
	_sysMsg.MsgType = field.NewString(tableName, "msg_type")
	_sysMsg.MsgBody = field.NewString(tableName, "msg_body")

	_sysMsg.fillFieldMap()

	return _sysMsg
}

// sysMsg 通知各种信息，有短信和平台通知两种
type sysMsg struct {
	sysMsgDo sysMsgDo

	ALL        field.Asterisk
	ID         field.Int64  // 数据id
	CreateTime field.Time   // 创建时间
	UpdateTime field.Time   // 更新时间
	DeleteTime field.Time   // 删除时间
	MsgType    field.String // 1表示平台通知 2表示电话通知
	MsgBody    field.String // 通知内容

	fieldMap map[string]field.Expr
}

func (s sysMsg) Table(newTableName string) *sysMsg {
	s.sysMsgDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysMsg) As(alias string) *sysMsg {
	s.sysMsgDo.DO = *(s.sysMsgDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysMsg) updateTableName(table string) *sysMsg {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.CreateTime = field.NewTime(table, "create_time")
	s.UpdateTime = field.NewTime(table, "update_time")
	s.DeleteTime = field.NewTime(table, "delete_time")
	s.MsgType = field.NewString(table, "msg_type")
	s.MsgBody = field.NewString(table, "msg_body")

	s.fillFieldMap()

	return s
}

func (s *sysMsg) WithContext(ctx context.Context) ISysMsgDo { return s.sysMsgDo.WithContext(ctx) }

func (s sysMsg) TableName() string { return s.sysMsgDo.TableName() }

func (s sysMsg) Alias() string { return s.sysMsgDo.Alias() }

func (s sysMsg) Columns(cols ...field.Expr) gen.Columns { return s.sysMsgDo.Columns(cols...) }

func (s *sysMsg) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysMsg) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 6)
	s.fieldMap["id"] = s.ID
	s.fieldMap["create_time"] = s.CreateTime
	s.fieldMap["update_time"] = s.UpdateTime
	s.fieldMap["delete_time"] = s.DeleteTime
	s.fieldMap["msg_type"] = s.MsgType
	s.fieldMap["msg_body"] = s.MsgBody
}

func (s sysMsg) clone(db *gorm.DB) sysMsg {
	s.sysMsgDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sysMsg) replaceDB(db *gorm.DB) sysMsg {
	s.sysMsgDo.ReplaceDB(db)
	return s
}

type sysMsgDo struct{ gen.DO }

type ISysMsgDo interface {
	gen.SubQuery
	Debug() ISysMsgDo
	WithContext(ctx context.Context) ISysMsgDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISysMsgDo
	WriteDB() ISysMsgDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISysMsgDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysMsgDo
	Not(conds ...gen.Condition) ISysMsgDo
	Or(conds ...gen.Condition) ISysMsgDo
	Select(conds ...field.Expr) ISysMsgDo
	Where(conds ...gen.Condition) ISysMsgDo
	Order(conds ...field.Expr) ISysMsgDo
	Distinct(cols ...field.Expr) ISysMsgDo
	Omit(cols ...field.Expr) ISysMsgDo
	Join(table schema.Tabler, on ...field.Expr) ISysMsgDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysMsgDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysMsgDo
	Group(cols ...field.Expr) ISysMsgDo
	Having(conds ...gen.Condition) ISysMsgDo
	Limit(limit int) ISysMsgDo
	Offset(offset int) ISysMsgDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysMsgDo
	Unscoped() ISysMsgDo
	Create(values ...*model.SysMsg) error
	CreateInBatches(values []*model.SysMsg, batchSize int) error
	Save(values ...*model.SysMsg) error
	First() (*model.SysMsg, error)
	Take() (*model.SysMsg, error)
	Last() (*model.SysMsg, error)
	Find() ([]*model.SysMsg, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysMsg, err error)
	FindInBatches(result *[]*model.SysMsg, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysMsg) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysMsgDo
	Assign(attrs ...field.AssignExpr) ISysMsgDo
	Joins(fields ...field.RelationField) ISysMsgDo
	Preload(fields ...field.RelationField) ISysMsgDo
	FirstOrInit() (*model.SysMsg, error)
	FirstOrCreate() (*model.SysMsg, error)
	FindByPage(offset int, limit int) (result []*model.SysMsg, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysMsgDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysMsgDo) Debug() ISysMsgDo {
	return s.withDO(s.DO.Debug())
}

func (s sysMsgDo) WithContext(ctx context.Context) ISysMsgDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysMsgDo) ReadDB() ISysMsgDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysMsgDo) WriteDB() ISysMsgDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysMsgDo) Session(config *gorm.Session) ISysMsgDo {
	return s.withDO(s.DO.Session(config))
}

func (s sysMsgDo) Clauses(conds ...clause.Expression) ISysMsgDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysMsgDo) Returning(value interface{}, columns ...string) ISysMsgDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysMsgDo) Not(conds ...gen.Condition) ISysMsgDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysMsgDo) Or(conds ...gen.Condition) ISysMsgDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysMsgDo) Select(conds ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysMsgDo) Where(conds ...gen.Condition) ISysMsgDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysMsgDo) Order(conds ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysMsgDo) Distinct(cols ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysMsgDo) Omit(cols ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysMsgDo) Join(table schema.Tabler, on ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysMsgDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysMsgDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysMsgDo) Group(cols ...field.Expr) ISysMsgDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysMsgDo) Having(conds ...gen.Condition) ISysMsgDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysMsgDo) Limit(limit int) ISysMsgDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysMsgDo) Offset(offset int) ISysMsgDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysMsgDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysMsgDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysMsgDo) Unscoped() ISysMsgDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysMsgDo) Create(values ...*model.SysMsg) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysMsgDo) CreateInBatches(values []*model.SysMsg, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysMsgDo) Save(values ...*model.SysMsg) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysMsgDo) First() (*model.SysMsg, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysMsg), nil
	}
}

func (s sysMsgDo) Take() (*model.SysMsg, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysMsg), nil
	}
}

func (s sysMsgDo) Last() (*model.SysMsg, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysMsg), nil
	}
}

func (s sysMsgDo) Find() ([]*model.SysMsg, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysMsg), err
}

func (s sysMsgDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysMsg, err error) {
	buf := make([]*model.SysMsg, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysMsgDo) FindInBatches(result *[]*model.SysMsg, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysMsgDo) Attrs(attrs ...field.AssignExpr) ISysMsgDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysMsgDo) Assign(attrs ...field.AssignExpr) ISysMsgDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysMsgDo) Joins(fields ...field.RelationField) ISysMsgDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysMsgDo) Preload(fields ...field.RelationField) ISysMsgDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysMsgDo) FirstOrInit() (*model.SysMsg, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysMsg), nil
	}
}

func (s sysMsgDo) FirstOrCreate() (*model.SysMsg, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysMsg), nil
	}
}

func (s sysMsgDo) FindByPage(offset int, limit int) (result []*model.SysMsg, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysMsgDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysMsgDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysMsgDo) Delete(models ...*model.SysMsg) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysMsgDo) withDO(do gen.Dao) *sysMsgDo {
	s.DO = *do.(*gen.DO)
	return s
}
